<h1>Graph Data Structure And Algorithms</h1>
Graph Data Structure is a collection of nodes connected by edges. It’s used to represent relationships between different entities. Graph algorithms are methods used to manipulate and analyze graphs, solving various problems like finding the shortest path or detecting cycles.
<h3>What is Graph Data Structure?</h3>
Graph is a non-linear data structure consisting of vertices and edges. The vertices are sometimes also referred to as nodes and the edges are lines or arcs that connect any two nodes in the graph. More formally a Graph is composed of a set of vertices( V ) and a set of edges( E ). The graph is denoted by G(V, E).<br>
Graph data structures are a powerful tool for representing and analyzing complex relationships between objects or entities. They are particularly useful in fields such as social network analysis, recommendation systems, and computer networks. In the field of sports data science, graph data structures can be used to analyze and understand the dynamics of team performance and player interactions on the field.
<h3>Components of a Graph:</h3><ul>
<li>Vertices: Vertices are the fundamental units of the graph. Sometimes, vertices are also known as vertex or nodes. Every node/vertex can be labeled or unlabeled.</li>
<li>Edges: Edges are drawn or used to connect two nodes of the graph. It can be ordered pair of nodes in a directed graph. Edges can connect any two nodes in any possible way. There are no rules. Sometimes, edges are also known as arcs. Every edge can be labelled/unlabelled.</li></ul>
<h3>Operations on Graphs:</h3><ul>
<li>Basic Operations:<ul>
<li>Insertion of Nodes/Edges in the graph – Insert a node into the graph.</li>
<li>Deletion of Nodes/Edges in the graph – Delete a node from the graph.</li>
<li>Searching on Graphs – Search an entity in the graph.</li>
<li>Traversal of Graphs – Traversing all the nodes in the graph.</li></ul></li>
<li>More Operations:<ul>
<li>Shortest Paths : From a source to a destination, a source to all other nodes and between all pairs.</li>
<li>Minimum Spanning Tee : In a weighted, connected undirected graph, finding the minimum weight edges to connect all.</li></ul></li></ul>
<h3>Applications of Graph:</h3>
Following are the real-life applications:<ul>
<li>If we recall all the previous data structures that we have studied like array, linked list, tree, etc. All these had some restrictions on structure (mostly linear and tree hierarchical which means no loops). Graph allows random connections between nodes which is useful in many real world problems where do have restrictions of previous data structures. </li>
<li>Used heavily in social networks. Everyone on the network is a vertex (or node) of the graph and if connected, then there is an edge. Now imagine all the features that you see, mutual friends, people that follow you, etc can seen as graph problems.</li>
<li>Neural Networks: Vertices represent neurons and edges represent the synapses between them. Neural networks are used to understand how our brain works and how connections change when we learn. The human brain has about 10<sup>11</sup> neurons and close to 10<sup>15</sup> synapses.</li>
<li>Compilers: Graph Data Structure is used extensively in compilers. They can be used for type inference, for so-called data flow analysis, register allocation, and many other purposes. They are also used in specialized compilers, such as query optimization in database languages.</li>
<li>Robot planning: Vertices represent states the robot can be in and the edges the possible transitions between the states. Such graph plans are used, for example, in planning paths for autonomous vehicles.</li>
<li>In GPS. The problems like finding the closest route, closest petrol pumps, etc are all soled using graph problems.</li>
<li>For optimizing the cost of connecting all locations of a network. For example, minimizing wire length in a wired network to make sure all devices are connected is a standard Graph problem called Minimum Spanning Tree.</li>
<li>Can be used to represent the interactions between players on a team, such as passes, shots, and tackles. Analyzing these interactions can provide insights into team dynamics and areas for improvement.</li>
<li>Can be used to represent the topology of computer networks, such as the connections between routers and switches.</li>
<li>Graphs are used to represent the connections between different places in a transportation network, such as roads and airports.</li>
<li>Dependencies in a software project (or any other type of project) can be seen as graph and generating a sequence to solve all tasks before dependents is a standard graph topological sorting algorithm.</li></ul>
<h2>Different types of graph algorithms:</h2>
<h3>How to find Shortest Paths from Source to all Vertices using Dijkstra’s Algorithm</h3><p>Given a weighted graph and a source vertex in the graph, find the shortest paths from the source to all the other vertices in the given graph.<br> Note: The given graph does not contain any negative edge.</p>
<h3>Articulation Points in a Graph</h3><p>A vertex v is an articulation point (also called cut vertex) if removing v increases the number of connected components.<br>Articulation points represent vulnerabilities in a connected network – single points whose failure would split the network into 2 or more components. They are useful for designing reliable networks.</p>
<h3>Kruskal’s Minimum Spanning Tree (MST) Algorithm</h3><p>In Kruskal’s algorithm, sort all edges of the given graph in increasing order. Then it keeps on adding new edges and nodes in the MST if the newly added edge does not form a cycle. It picks the minimum weighted edge at first and the maximum weighted edge at last. Thus we can say that it makes a locally optimal choice in each step in order to find the optimal solution. Hence this is a Greedy Algorithm.</p>
<h3>Topological Sorting</h3><p>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u-v, vertex u comes before v in the ordering.<br>Note: Topological Sorting for a graph is not possible if the graph is not a DAG.</p>
<h3>Bellman–Ford Algorithm</h3><p>Imagine you have a map with different cities connected by roads, each road having a certain distance. The Bellman–Ford algorithm is like a guide that helps you find the shortest path from one city to all other cities, even if some roads have negative lengths. It’s like a GPS for computers, useful for figuring out the quickest way to get from one point to another in a network. In this article, we’ll take a closer look at how this algorithm works and why it’s so handy in solving everyday problems.</p>
<h3>Floyd Warshall Algorithm</h3><p>The Floyd-Warshall algorithm, named after its creators Robert Floyd and Stephen Warshall, is a fundamental algorithm in computer science and graph theory. It is used to find the shortest paths between all pairs of nodes in a weighted graph. This algorithm is highly efficient and can handle graphs with both positive and negative edge weights, making it a versatile tool for solving a wide range of network and connectivity problems.</p>
<h3>Prim’s Algorithm for Minimum Spanning Tree (MST)</h3><p>The algorithm starts with an empty spanning tree. The idea is to maintain two sets of vertices. The first set contains the vertices already included in the MST, and the other set contains the vertices not yet included. At every step, it considers all the edges that connect the two sets and picks the minimum weight edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST. </p>
<h3>Detect Cycle in a Directed Graph</h3><p>Given the root of a Directed graph , The task is to check whether the graph contains a cycle or not.</p>
<h3>Depth First Search or DFS for a Graph</h3><p>Depth First Traversal (or DFS) for a graph is similar to Depth First Traversal of a tree. Like Trees, we traverse all adjacent one by one, when we traverse an adjacent, we finish traversal of all vertices reachable through the adjacent completely. After we finish one adjacent and its reachable, we go to the next adjacent and finish all reachable through next and continue this way. Similar to tree where we first completely traverse the left subtree and then go to the right subtree. The only catch here is, that, unlike trees, graphs may contain cycles (a node may be visited twice). To avoid processing a node more than once, use a boolean visited array.</p>
<h3>Breadth First Search or BFS for a Graph</h3><p>Breadth First Search (BFS) is a fundamental graph traversal algorithm. It begins with a node, then first traverses all its adjacent. Once all adjacent are visited, then their adjacent are traversed. This is different from DFS in a way that closest vertices are visited before others. We mainly traverse vertices level by level. A lot of popular graph algorithms like Dijkstra’s shortest path, Kahn’s Algorithm, and Prim’s algorithm are based on BFS. BFS itself can be used to detect cycle in a directed and undirected graph, find shortest path in an unweighted graph and many more problems.</p>